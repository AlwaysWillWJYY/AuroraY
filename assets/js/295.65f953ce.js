(window.webpackJsonp=window.webpackJsonp||[]).push([[295],{753:function(v,_,a){"use strict";a.r(_);var n=a(1),r=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"java基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[v._v("#")]),v._v(" Java基础")]),v._v(" "),_("p",[_("strong",[v._v("1、ArrayList和LinkedList的简介和区别。")])]),v._v(" "),_("p",[v._v("ArrayList和LinkedList都是Java中常用的集合类，但它们的实现方式不同，有着一些区别。")]),v._v(" "),_("p",[v._v("ArrayList是通过数组实现的，它可以随机访问元素，但在插入或删除元素时可能需要移动数组中的元素，因此在操作频繁的情况下效率可能较低。")]),v._v(" "),_("p",[v._v("LinkedList是通过链表实现的，它不能像ArrayList那样随机访问元素，需要遍历整个链表来访问某个元素，但在插入或删除元素时只需要修改相邻元素的指针，因此在操作频繁的情况下效率可能更高。")]),v._v(" "),_("p",[v._v("下面是ArrayList和LinkedList的主要区别：")]),v._v(" "),_("ol",[_("li",[v._v("内部实现方式：ArrayList是通过数组实现的，而LinkedList是通过链表实现的。")]),v._v(" "),_("li",[v._v("访问方式：ArrayList支持随机访问，可以通过索引值快速访问元素，而LinkedList只能通过遍历来访问元素。")]),v._v(" "),_("li",[v._v("插入和删除操作的效率：ArrayList在插入和删除元素时需要移动数组中的元素，因此效率可能较低，而LinkedList在插入和删除元素时只需要修改相邻元素的指针，因此效率可能更高。")]),v._v(" "),_("li",[v._v("内存占用：ArrayList在存储元素时需要预先分配一定的内存空间，因此可能会浪费一些空间，而LinkedList不需要预先分配内存空间，因此可以更好地利用内存。")]),v._v(" "),_("li",[v._v("线程安全性：ArrayList不是线程安全的，需要在多线程环境下进行同步操作，而LinkedList在单线程和多线程环境下都是安全的。")])]),v._v(" "),_("p",[v._v("根据实际使用场景，我们可以选择合适的集合类来提高程序的效率。如果需要频繁地访问元素，可以选择ArrayList；如果需要频繁地插入或删除元素，可以选择LinkedList。")]),v._v(" "),_("p",[_("strong",[v._v("2、 HashMap底层实现，扩容机制，执行流程")])]),v._v(" "),_("p",[v._v("HashMap 是 Java 中常用的一种数据结构，用于存储键值对。它的底层实现是基于哈希表，也就是散列表，是一种通过哈希函数将不同的 key 映射到不同的索引位置上，从而实现快速的增删改查操作的数据结构。")]),v._v(" "),_("p",[v._v("HashMap 的底层实现是一个数组和链表（或红黑树）的结合体，称之为桶（bucket）。数组的每个元素都是一个链表的头节点，每个链表节点保存一个键值对。当链表长度达到一定的阈值时，链表就会转换成红黑树，以提高查找效率。")]),v._v(" "),_("p",[v._v("HashMap 的扩容机制是在当前数组大小不足以容纳所有元素时，会将数组大小扩大一倍，然后将所有元素重新插入到新的数组中。扩容操作会带来一定的性能开销，因为需要重新计算哈希值、重新定位桶的位置，以及重新插入元素。")]),v._v(" "),_("p",[v._v("下面是 HashMap 的执行流程：")]),v._v(" "),_("ol",[_("li",[v._v("初始化HashMap，分配一个数组空间，数组长度默认为16。")]),v._v(" "),_("li",[v._v("将 key 值通过哈希函数得到其在数组中的下标位置。")]),v._v(" "),_("li",[v._v("如果下标位置对应的桶为空，直接将键值对插入桶中，然后结束。")]),v._v(" "),_("li",[v._v("如果下标位置对应的桶不为空，遍历桶中的所有节点，查找是否有键值对的 key 与插入的 key 相同。如果存在相同的 key，就用新的 value 替换旧的 value，然后结束。")]),v._v(" "),_("li",[v._v("如果下标位置对应的桶中没有与插入的 key 相同的键值对，就将新的键值对插入到桶的末尾。如果链表长度达到一定的阈值（默认为8），就将链表转换成红黑树。")]),v._v(" "),_("li",[v._v("如果桶的元素个数超过了负载因子（默认为0.75），就将数组大小扩大一倍，并重新插入所有的键值对。")])]),v._v(" "),_("p",[_("strong",[v._v("负载因子结合扩容详解？")])]),v._v(" "),_("p",[v._v("HashMap是Java中常用的数据结构之一，它是一种基于哈希表实现的键值对存储容器。在使用HashMap时，会涉及到加载因子和扩容机制。")]),v._v(" "),_("p",[v._v("加载因子是HashMap在内部存储中使用的一个参数，用于表示HashMap何时需要扩容。默认加载因子是0.75，表示当HashMap中的元素数量达到容量的75%时，就会触发扩容操作。")]),v._v(" "),_("p",[v._v("扩容机制是指当HashMap中的元素数量达到加载因子时，自动增加HashMap的容量，以保证HashMap的性能。在HashMap的内部实现中，扩容会涉及到重新计算元素的哈希值和重新分配元素的位置，这个过程可能比较耗时。因此，在实际使用中，需要根据具体的场景来合理设置HashMap的初始容量和加载因子。")]),v._v(" "),_("p",[v._v("当HashMap中的元素数量达到容量的75%时，HashMap会自动进行扩容操作。扩容时，HashMap会将原来的数组扩大为原来的两倍，并将原来的元素重新分配到新的数组中。在这个过程中，需要重新计算元素的哈希值和重新分配元素的位置，所以扩容操作可能比较耗时。")]),v._v(" "),_("p",[v._v("需要注意的是，扩容操作会导致HashMap中的所有元素的位置发生变化，因此在扩容过程中可能会导致一些性能问题。为了避免这种情况，可以通过设置合适的初始容量和加载因子来减少扩容的次数，从而提高HashMap的性能。")]),v._v(" "),_("p",[_("strong",[v._v("3、HashMap为何线程不安全，不安全主要包括那些方面？")])]),v._v(" "),_("p",[v._v("HashMap 不安全的主要原因是它不是线程安全的，也就是说，在多个线程同时访问 HashMap 时可能会导致数据不一致或者意外的异常情况发生。")]),v._v(" "),_("p",[v._v("具体来说，以下是一些导致 HashMap 不安全的常见情况：")]),v._v(" "),_("ol",[_("li",[v._v("线程冲突：当多个线程同时访问 HashMap 的时候，如果它们对同一个键值对进行修改操作，可能会导致数据不一致的情况发生。")]),v._v(" "),_("li",[v._v("容量不足：当 HashMap 中的元素数量增加时，如果没有及时调整容量，可能会导致哈希冲突的发生，影响查询效率。")]),v._v(" "),_("li",[v._v("并发扩容：在 HashMap 进行扩容操作的过程中，如果多个线程同时进行操作，可能会导致数据结构被破坏，引发意外的异常情况。")]),v._v(" "),_("li",[v._v("存在重复键值：在 HashMap 中，键值对的 key 必须是唯一的，如果插入了重复的 key，可能会导致后续操作无法正确执行。")])]),v._v(" "),_("p",[v._v("因此，如果需要在多线程环境中使用 HashMap，需要对其进行加锁或者使用线程安全的 Map 实现，例如 ConcurrentHashMap。")]),v._v(" "),_("p",[_("strong",[v._v("4、ConcurrentHashMap的实现原理？")])]),v._v(" "),_("p",[v._v("ConcurrentHashMap是Java集合框架中的一种并发集合，它提供了高效且线程安全的哈希表实现。它的实现原理可以简单地分为三个部分：数据结构、并发控制和哈希算法。")]),v._v(" "),_("p",[v._v("​\t数据结构")]),v._v(" "),_("p",[v._v("ConcurrentHashMap的数据结构由多个Segment（段）组成，每个Segment都是一个独立的哈希表，可以独立地进行并发操作。每个Segment内部使用了和HashMap类似的数组+链表结构来保存数据。")]),v._v(" "),_("p",[v._v("​\t并发控制")]),v._v(" "),_("p",[v._v("ConcurrentHashMap的并发控制使用了一种叫做分离锁（Segmented Locking）的技术。即在每个Segment内部都有一个独立的锁来控制并发访问。这样，在不同的Segment上进行并发操作时，不会相互阻塞，可以提高并发访问的效率。而且在读取操作上，读锁支持并发，可以提高读操作的并发性能。")]),v._v(" "),_("p",[v._v("​\t哈希算法")]),v._v(" "),_("p",[v._v("ConcurrentHashMap的哈希算法和HashMap类似，都是采用了哈希表的方式来存储数据。不过在处理哈希冲突时，ConcurrentHashMap采用了一种比较高效的方式，即使用了链表和红黑树两种数据结构来处理冲突，从而提高了并发访问的性能。")]),v._v(" "),_("p",[v._v("总的来说，ConcurrentHashMap通过数据结构、并发控制和哈希算法三个方面的优化，实现了高效且线程安全的哈希表。在多线程环境下，ConcurrentHashMap的性能表现比HashMap要好得多。")]),v._v(" "),_("p",[v._v("有两种结构可以使得线程安全。没说全。")]),v._v(" "),_("p",[_("strong",[v._v("5、什么是Hash冲突？怎么解决hash冲突？")])]),v._v(" "),_("p",[v._v("Hash冲突指的是在散列表中，不同的键值对可能会被映射到相同的散列桶（hash bucket）中，造成冲突的现象。这种情况下，如果直接将键值对存储到散列桶中，会导致之前已经存储在该散列桶中的键值对被覆盖，从而出现数据丢失的情况。")]),v._v(" "),_("p",[v._v("解决Hash冲突的方法有很多种，常用的方法包括：")]),v._v(" "),_("ol",[_("li",[v._v("链地址法（Chaining）：将散列桶设计成链表的形式，当多个键值对映射到同一散列桶时，将它们存储在同一个链表中。这种方法可以保证不会出现数据丢失的情况，但是需要占用更多的空间。")]),v._v(" "),_("li",[v._v("开放地址法（Open addressing）：当出现Hash冲突时，通过一定的算法找到下一个可用的散列桶来存储键值对。其中最常用的算法包括线性探测（Linear Probing）、二次探测（Quadratic Probing）和双重散列（Double Hashing）等。")]),v._v(" "),_("li",[v._v("建立更好的Hash函数：通过设计更好的Hash函数，可以减少Hash冲突的概率，从而提高散列表的性能。例如，一些常用的Hash函数包括MD5、SHA-1、SHA-256等。")])]),v._v(" "),_("p",[v._v("总之，解决Hash冲突的方法有很多种，选择合适的方法需要考虑到实际应用的场景、数据结构的特点以及性能要求等因素。")]),v._v(" "),_("p",[_("strong",[v._v("6、锁机制")])]),v._v(" "),_("p",[v._v("锁机制是计算机科学中的一个重要概念，用于确保在并发情况下多个进程或线程之间的数据同步。锁机制可以分为两种类型：共享锁和排他锁。")]),v._v(" "),_("p",[v._v("共享锁是指多个进程或线程可以同时获取该锁，以读取共享资源，但是不能进行写操作。这种锁机制通常用于多个进程或线程同时需要读取同一个数据结构的情况。")]),v._v(" "),_("p",[v._v("排他锁是指只有一个进程或线程可以获取该锁，以进行写操作，其他进程或线程需要等待该锁被释放后才能获取该锁。这种锁机制通常用于对同一个数据结构进行写操作的情况。")]),v._v(" "),_("p",[v._v("锁机制在多线程和并发编程中非常重要，可以确保数据的正确性和可靠性。在实际应用中，常用的锁机制包括互斥锁、读写锁、自旋锁等。")]),v._v(" "),_("p",[_("strong",[v._v("7、分布式锁和项目中的实现")])]),v._v(" "),_("p",[v._v("分布式锁是一种在分布式系统中实现互斥访问共享资源的机制。在分布式系统中，多个进程或线程需要协调共享资源的访问，而分布式锁则可以保证同一时刻只有一个进程或线程能够访问共享资源，从而避免了数据的冲突和不一致性。")]),v._v(" "),_("p",[v._v("在我的简历项目中，我曾经实现过一种基于Redis的分布式锁。具体实现方式是在Redis中创建一个key，用于表示共享资源被锁定的状态，同时设置一个过期时间，确保锁最终会被释放。在需要访问共享资源的进程或线程中，首先尝试获取这个锁，如果获取成功，则可以执行需要的操作，否则等待一段时间后重试。当进程或线程完成对共享资源的访问后，需要手动释放锁。")]),v._v(" "),_("p",[v._v("这种分布式锁的实现可以很好地解决分布式系统中共享资源的访问问题。但是需要注意的是，在实现分布式锁时需要考虑多种情况，比如锁的粒度、超时时间、重试机制等，以保证分布式锁的可靠性和高效性。")]),v._v(" "),_("p",[_("strong",[v._v("8、可重入锁和lock的区别。")])]),v._v(" "),_("p",[v._v("可重入锁和lock是Java中两个不同的概念。")]),v._v(" "),_("p",[v._v("Lock是Java提供的一种线程同步的机制，用于实现互斥访问共享资源。与synchronized关键字不同的是，Lock可以提供更多的功能，比如可中断锁、超时锁和公平锁等。Lock通过lock()方法获取锁，通过unlock()方法释放锁，可以在多个线程之间共享使用。")]),v._v(" "),_("p",[v._v("可重入锁是一种特殊的锁，它允许同一个线程在持有锁的情况下再次获取该锁。这种锁机制可以避免死锁的情况，并提高锁的性能。在Java中，ReentrantLock就是一种可重入锁的实现，它可以通过lock()方法获取锁，在同一个线程中可以多次调用lock()方法，只要在每次获取锁之后都对应着一个相同的unlock()方法调用，就可以成功释放锁。")]),v._v(" "),_("p",[v._v("因此，可重入锁与Lock之间的关系是，可重入锁是Lock机制的一种实现，它允许同一个线程在持有锁的情况下再次获取该锁，从而实现更灵活的同步控制。")]),v._v(" "),_("p",[_("strong",[v._v("9、Redission原理")])]),v._v(" "),_("p",[v._v("Redisson是基于Redis的分布式Java对象和服务框架，提供了分布式锁、分布式集合、分布式队列等功能，支持多种数据结构和对象的存储、访问和操作。其核心原理是利用Redis提供的数据结构和命令，通过Java客户端对Redis进行访问和操作，实现分布式对象和服务的管理和控制。")]),v._v(" "),_("p",[v._v("具体来说，Redisson的实现原理主要包括以下几个方面：")]),v._v(" "),_("ol",[_("li",[v._v("Redisson客户端：Redisson使用Java客户端对Redis进行访问和操作，客户端负责与Redis建立连接、发送命令、接收响应等操作。")]),v._v(" "),_("li",[v._v("Redis命令：Redisson使用Redis提供的数据结构和命令实现分布式对象和服务的管理和控制，比如使用Redis的SET命令实现分布式锁，使用LIST命令实现分布式队列。")]),v._v(" "),_("li",[v._v("序列化：Redisson支持多种数据结构和对象的存储和访问，需要将对象进行序列化和反序列化，以便于在Redis中进行存储和操作。")]),v._v(" "),_("li",[v._v("线程安全：Redisson提供了多种线程安全的数据结构和对象，保证了多线程环境下的数据一致性和线程安全。")]),v._v(" "),_("li",[v._v("分布式算法：Redisson还实现了多种分布式算法，如分布式锁、分布式集合、分布式队列等，可以在分布式环境下保证数据的一致性和可靠性。")])]),v._v(" "),_("p",[v._v("总的来说，Redisson通过Java客户端对Redis进行访问和操作，通过Redis提供的数据结构和命令实现分布式对象和服务的管理和控制，以及提供了多种线程安全和分布式算法的支持，从而实现了一个完整的分布式Java对象和服务框架。")]),v._v(" "),_("p",[_("strong",[v._v("10、sycn原理")])]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v(" 是 Java 中用于实现线程同步的关键字，它可以用于修饰方法和代码块。它的实现原理主要涉及到 Java 中的对象监视器（monitor）和内置锁（Intrinsic Lock）。")]),v._v(" "),_("p",[v._v("在 Java 中，每个对象都有一个与之关联的监视器（monitor），也称为管程（monitor）。Java 中的监视器本质上是一种同步锁，每个对象只有一个监视器，当某个线程请求获得该对象的监视器时，该线程就进入到该对象的监视器的等待池中，直到该对象的监视器被释放为止。")]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v(" 就是利用对象的监视器实现线程的同步。当一个线程进入一个 "),_("code",[v._v("synchronized")]),v._v(" 方法或代码块时，它会自动获取该方法或代码块所在对象的监视器，如果该监视器已经被其他线程获取，那么该线程就会进入等待池中等待，直到该监视器被释放为止。在 "),_("code",[v._v("synchronized")]),v._v(" 方法或代码块执行结束后，该线程会自动释放该对象的监视器，以便其他线程可以获取该监视器。")]),v._v(" "),_("p",[v._v("需要注意的是，当一个线程获取了一个对象的监视器后，其他线程不能获取该对象的任何 "),_("code",[v._v("synchronized")]),v._v(" 方法或代码块的监视器，直到该线程释放了该对象的监视器。")]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v(" 的另一个重要特性是可重入性，即当一个线程已经获取了某个对象的监视器后，它可以再次获取该对象的监视器，而不会因为自己已经持有该监视器而进入等待池中，这样可以避免死锁的发生。")]),v._v(" "),_("p",[v._v("总的来说，"),_("code",[v._v("synchronized")]),v._v(" 利用对象的监视器实现了线程的同步，保证了多线程访问共享资源的安全性和可见性。")]),v._v(" "),_("p",[_("strong",[v._v("11、 synchronized锁的类型介绍和升级流程")])]),v._v(" "),_("p",[v._v("Synchronized锁是Java中用于实现线程同步的一种基本机制。它可以保证在同一时刻只有一个线程能够访问被synchronized锁保护的代码块，从而保证了线程安全。")]),v._v(" "),_("p",[v._v("在Java中，synchronized锁分为两种类型：对象锁和类锁。对象锁是基于对象的，每个对象都有一个锁，当线程进入synchronized代码块时，它必须先获得该对象的锁才能执行代码块中的代码。类锁是基于类的，每个类只有一个锁，当线程进入synchronized代码块时，它必须先获得该类的锁才能执行代码块中的代码。")]),v._v(" "),_("p",[v._v("在Java中，synchronized锁的升级过程是从无锁状态到偏向锁状态，再到轻量级锁状态，最后到重量级锁状态。锁状态的升级过程是由JVM自动管理的，程序员无法控制。")]),v._v(" "),_("p",[v._v("偏向锁是JDK1.6中引入的一种锁优化机制，它可以在单线程环境下减少锁的竞争，提高程序的性能。当一个线程获取了对象锁后，会将锁的持有者信息记录在对象头中，下次再进入该代码块时，无需竞争锁，直接判断对象头中是否是同一个线程即可。")]),v._v(" "),_("p",[v._v("轻量级锁是JDK1.6中引入的另一种锁优化机制，它针对的是多线程竞争的情况。当一个线程进入synchronized代码块时，JVM会尝试使用CAS操作来获取锁，如果获取成功，则该线程持有了轻量级锁，可以直接执行代码块中的代码。如果获取失败，则说明锁已被其他线程持有，那么当前线程就会膨胀为重量级锁，等待其他线程释放锁。")]),v._v(" "),_("p",[v._v("重量级锁是最基本的锁形式，它采用了传统的互斥量实现，即当一个线程持有锁时，其他线程必须等待锁的释放才能竞争。重量级锁是最慢的锁形式，它会导致线程的阻塞和唤醒，从而影响程序的性能。")]),v._v(" "),_("p",[v._v("需要注意的是，在Java 5之后，引入了一种新的锁机制——ReentrantLock，它比synchronized锁更加灵活、可控。ReentrantLock支持公平锁和非公平锁，可以实现可重入、可中断、超时等特性。但是，使用ReentrantLock需要程序员手动管理锁的获取和释放，不如synchronized锁简单易用。")]),v._v(" "),_("p",[_("strong",[v._v("12、慢查询定位，优化和解决？")])]),v._v(" "),_("p",[v._v("慢查询（Slow query）是指执行时间较长、查询速度较慢的 SQL 查询语句，这些查询语句会占用数据库服务器的资源，导致系统响应变慢或者系统负载过高。通常情况下，执行时间超过一定阈值（如几秒钟）的 SQL 查询语句都可以被认为是慢查询。")]),v._v(" "),_("p",[v._v("定位慢查询可以通过以下方式：")]),v._v(" "),_("ol",[_("li",[v._v("使用数据库的性能分析工具，如 MySQL 的慢查询日志（Slow Query Log），记录 SQL 查询语句的执行时间和执行次数等信息，以便分析和定位慢查询。")]),v._v(" "),_("li",[v._v("使用监控工具，如 Nagios、Cacti、Zabbix 等监控系统的性能指标，例如 CPU 利用率、内存使用率、磁盘 I/O 等，以帮助定位慢查询的原因。")]),v._v(" "),_("li",[v._v("使用一些工具，例如 pt-query-digest、mysqldumpslow 等，对数据库中的慢查询进行分析和排查。")])]),v._v(" "),_("p",[v._v("解决慢查询的方法包括：")]),v._v(" "),_("ol",[_("li",[v._v("优化 SQL 查询语句，例如使用索引、减少表连接、避免子查询、优化 where 子句等。")]),v._v(" "),_("li",[v._v("使用缓存技术，例如 Memcached、Redis 等，将常用的查询结果缓存起来，减少数据库的查询次数。")]),v._v(" "),_("li",[v._v("升级硬件，例如增加 CPU、内存等，以提高数据库服务器的性能。")]),v._v(" "),_("li",[v._v("对于一些无法优化的查询，可以考虑将其转移到其他数据库、将数据进行分区或者归档等方式来减少查询负载。")])]),v._v(" "),_("p",[_("strong",[v._v("13、死锁产生原因？如何解决？")])]),v._v(" "),_("p",[v._v("死锁是指在并发编程中，两个或多个进程（线程）持有对方需要的资源，导致它们都无法继续执行的一种情况。产生死锁的主要原因是由于进程（线程）之间互相竞争有限的资源，如共享内存、硬盘、网络连接等。")]),v._v(" "),_("p",[v._v("解决死锁的方法通常有以下几种：")]),v._v(" "),_("ol",[_("li",[v._v("避免死锁：通过在编程设计中遵循一定的规则来避免死锁的产生，例如避免进程（线程）同时请求多个资源、按照固定的顺序请求资源等。")]),v._v(" "),_("li",[v._v("检测死锁：通过实时监控系统中的资源分配情况，及时发现死锁的产生，并采取相应的措施来解除死锁。")]),v._v(" "),_("li",[v._v("解除死锁：通过终止某个或多个进程（线程）来解除死锁，或通过资源剥夺来满足死锁中某个或多个进程（线程）的资源请求，从而使它们能够继续执行。")]),v._v(" "),_("li",[v._v("预防死锁：通过资源预分配、资源共享等方式来避免进程（线程）之间的资源竞争，从而预防死锁的发生。")])]),v._v(" "),_("p",[v._v("在实际应用中，通常采用以上多种方法的组合，来有效地解决死锁问题。")]),v._v(" "),_("p",[_("strong",[v._v("14、抽象类和接口的区别？")])]),v._v(" "),_("p",[v._v("接口（Interface）和抽象类（Abstract Class）是面向对象编程中两个重要的概念，它们都可以用来实现多态性和代码重用性，但它们之间有几个重要的区别。")]),v._v(" "),_("p",[v._v("​\t实现方式")]),v._v(" "),_("p",[v._v("接口是一组抽象方法的集合，没有方法体，所有的方法都是公共的抽象方法，需要由实现该接口的类来具体实现方法的功能。")]),v._v(" "),_("p",[v._v("抽象类是一个类，可以包含抽象方法（没有方法体），也可以包含非抽象方法（有方法体），子类需要实现其中的抽象方法，而非抽象方法可以被继承和直接使用。")]),v._v(" "),_("p",[v._v("​\t继承方式")]),v._v(" "),_("p",[v._v("类可以继承一个抽象类，并且只能继承一个抽象类，但类可以实现多个接口，从而实现多重继承。")]),v._v(" "),_("p",[v._v("​\t访问修饰符")]),v._v(" "),_("p",[v._v("接口中的方法默认为 public，不能有 private 和 protected 方法。抽象类中的方法可以有不同的访问修饰符。")]),v._v(" "),_("p",[v._v("​\t成员变量")]),v._v(" "),_("p",[v._v("接口中只能定义常量，即 public static final 类型的变量。抽象类中可以定义普通变量和常量。")]),v._v(" "),_("p",[v._v("​\t构造方法")]),v._v(" "),_("p",[v._v("接口没有构造方法。抽象类可以有构造方法，但是不能直接被实例化。")]),v._v(" "),_("p",[v._v("​\t多态性")]),v._v(" "),_("p",[v._v("由于 Java 只支持单继承，但是一个类可以实现多个接口，所以接口更适合实现多态性的需求。")]),v._v(" "),_("p",[v._v("​\t适用场景")]),v._v(" "),_("p",[v._v("接口适合用于定义规范，描述对象之间的通用特性。抽象类适合用于代码重用，尤其是在多个子类中存在相同的方法或属性的情况下。")]),v._v(" "),_("p",[v._v("综上所述，接口和抽象类各有优缺点，开发者应根据具体需求和设计思路来选择合适的实现方式。")]),v._v(" "),_("p",[_("strong",[v._v("15、 static修饰的访问非static修出现的问题，以及为什么会出现这个问题，那么应该如何访问？")])]),v._v(" "),_("p",[v._v("当一个成员变量或方法被"),_("code",[v._v("static")]),v._v("修饰时，它将成为该类的静态成员，即该成员将与类的实例无关。这意味着，即使没有创建该类的实例，静态成员也可以被访问。")]),v._v(" "),_("p",[v._v("然而，当一个非静态成员（例如成员变量或方法）被访问时，必须通过类的实例来访问它。因此，如果试图从静态方法或静态代码块中访问非静态成员，将会出现编译错误。这是因为在没有实例的情况下，无法访问非静态成员。")]),v._v(" "),_("p",[_("strong",[v._v("16、hashtale底层实现？")])]),v._v(" "),_("p",[v._v("哈希表（Hashtable）是一种基于散列表（Hash）实现的数据结构，用于快速存储和查找键值对。它的底层实现包括以下几个关键部分：")]),v._v(" "),_("ol",[_("li",[v._v("数组：哈希表的底层通常使用一个数组来存储数据。数组的每个元素是一个桶（Bucket），用于存储键值对。数组的大小通常是一个质数，以避免哈希冲突。")]),v._v(" "),_("li",[v._v("哈希函数：哈希函数是将任意长度的输入（比如键）映射到固定长度的输出（比如数组索引）的函数。哈希函数应该具有良好的分布性，即不同的输入应该被映射到尽可能不同的输出。这可以减少哈希冲突的发生。")]),v._v(" "),_("li",[v._v("冲突解决策略：由于哈希函数可能将不同的输入映射到同一个输出，因此可能会发生哈希冲突。冲突解决策略用于解决这种情况。常见的冲突解决策略包括链式法和开放定址法。")]),v._v(" "),_("li",[v._v("链式法：当发生哈希冲突时，使用链式法将键值对添加到桶的链表中。这意味着同一个桶中可能会有多个键值对，需要遍历链表才能找到目标键值对。")]),v._v(" "),_("li",[v._v("开放定址法：当发生哈希冲突时，使用开放定址法在其他可用的桶中查找空闲位置，将键值对添加到这个位置。这意味着同一个桶中只会有一个键值对，但可能需要遍历多个桶才能找到目标键值对。")])]),v._v(" "),_("p",[v._v("综上所述，哈希表的底层实现包括数组、哈希函数和冲突解决策略。在实现哈希表时，需要选择适当的哈希函数和冲突解决策略，以便实现高效的键值对存储和查找。")]),v._v(" "),_("p",[_("strong",[v._v("17、 try中有return。finally中也有return，finally会执行吗")])]),v._v(" "),_("p",[v._v("无论在 "),_("code",[v._v("try")]),v._v(" 块中是否存在 "),_("code",[v._v("return")]),v._v(" 语句，"),_("code",[v._v("finally")]),v._v(" 块总是会执行。当 "),_("code",[v._v("try")]),v._v(" 块中存在 "),_("code",[v._v("return")]),v._v(" 语句时，先执行 "),_("code",[v._v("finally")]),v._v(" 块，然后才会将 "),_("code",[v._v("return")]),v._v(" 值返回给调用方。")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("finally")]),v._v(" 块中使用 "),_("code",[v._v("return")]),v._v(" 语句会覆盖 "),_("code",[v._v("try")]),v._v(" 块中的 "),_("code",[v._v("return")]),v._v(" 语句，因此如果在 "),_("code",[v._v("finally")]),v._v(" 块中使用 "),_("code",[v._v("return")]),v._v(" 语句，它将成为最终的返回值。这意味着，如果在 "),_("code",[v._v("finally")]),v._v(" 块中使用了 "),_("code",[v._v("return")]),v._v(" 语句，那么 "),_("code",[v._v("try")]),v._v(" 块中的任何 "),_("code",[v._v("return")]),v._v(" 语句的返回值都会被忽略。")]),v._v(" "),_("p",[_("strong",[v._v("18、try中有return，finally会被执行吗？")])]),v._v(" "),_("p",[v._v("无论try语句块中是否包含return语句，finally语句块都会被执行。")]),v._v(" "),_("p",[v._v("当try语句块中包含return语句时，finally语句块会在return语句执行之前被执行。也就是说，如果在try语句块中执行了return语句，则在返回函数调用者之前，finally语句块会被执行。")]),v._v(" "),_("p",[_("strong",[v._v("19、try中有return。catch中有return，finally会被执行吗？")])]),v._v(" "),_("p",[v._v("无论 try 中是否有 return，catch 中是否有 return，finally 块都会被执行。")]),v._v(" "),_("p",[v._v("finally 块中的语句会在 try 或 catch 中的任何 return 语句执行之前执行。即使在 try 或 catch 中出现异常或错误，finally 中的代码也会被执行。finally 块通常用于释放资源、清理代码或者确保某些代码始终得到执行。")]),v._v(" "),_("p",[v._v("需要注意的是，如果在 finally 块中也有 return 语句，它会覆盖 try 或 catch 中的 return 语句，因为 finally 块中的代码总是在 return 语句之前执行。")]),v._v(" "),_("p",[_("strong",[v._v("20、父子类的静态代码块，构造方法和代码块的执行顺序？")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("测试静态代码块执行顺序")])]),v._v(" "),_("li",[_("p",[v._v("1、static能修饰的类只有静态内部类")])]),v._v(" "),_("li",[_("p",[v._v("2、静态方法不能直接访问非静态成员（方法，成员变量）")])]),v._v(" "),_("li",[_("p",[v._v("3、静态代码块在类加载的时候，就直接加载，且只执行一次")])]),v._v(" "),_("li",[_("p",[v._v("4，执行顺序：父类静态代码块与静态成员--\x3e")])]),v._v(" "),_("li",[_("p",[v._v("子类静态代码块与静态成员--\x3e")])]),v._v(" "),_("li",[_("p",[v._v("父类代码块--\x3e")])]),v._v(" "),_("li",[_("p",[v._v("父类构造方法--\x3e")])]),v._v(" "),_("li",[_("p",[v._v("子类代码块--\x3e")])]),v._v(" "),_("li",[_("p",[v._v("子类构造方法--")])])]),v._v(" "),_("p",[_("strong",[v._v("小红书")])]),v._v(" "),_("p",[_("strong",[v._v("1、JDK、JRE、JVM的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("2、重载和重写的区别？")])]),v._v(" "),_("p",[v._v("重载实现的是编译时的多态性 ，重写实现的运行时的多态性")]),v._v(" "),_("p",[_("strong",[v._v("3、String三姐妹的区别")])]),v._v(" "),_("p",[v._v("StringBuffer是一个线程安全的可修改字符的序列，StringBuilder是线程不安全的，具有更高的效率。")]),v._v(" "),_("p",[_("strong",[v._v("4、==和equals的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("5、ArrayList和LinkedList的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("6、final关键字的作用？")])]),v._v(" "),_("p",[v._v("修饰类、修饰方法、修饰变量、修饰方法入参")]),v._v(" "),_("p",[_("strong",[v._v("7、int和Integer的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("8、接口和抽象类的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("9、HashMap和HashTable的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("10、Error和Exception的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("11、静态变量和实例变量的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("12、说说List、Set、Queue、Map的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("13、进程和线程的区别？")])]),v._v(" "),_("p",[v._v("拥有的资源、运行空间、上下文的切换、通信方面？")]),v._v(" "),_("p",[_("strong",[v._v("14、HashMap和TreeMap的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("15、谈谈异步、同步、阻塞和非阻塞的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("16、Vector、ArrayList和LinkedList的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("17、TCP协议和UDP协议的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("18、TCP的三次握手过程？为什么不是四次握手？为什么不是两次握手？")])]),v._v(" "),_("p",[v._v("//待复习")]),v._v(" "),_("p",[_("strong",[v._v("19、说说OSI七层模型，以及每层的作用？")])]),v._v(" "),_("p",[_("strong",[v._v("20、GET和POST的请求的区别？")])]),v._v(" "),_("p",[_("strong",[v._v("21、TCP的四次挥手过程？")])]),v._v(" "),_("p",[_("strong",[v._v("22、final、finally和finalize的区别")])]),v._v(" "),_("p",[_("strong",[v._v("23、TCP如何保证传输可靠性？")])]),v._v(" "),_("p",[_("strong",[v._v("24、谈谈你对Spring的理解")])]),v._v(" "),_("p",[_("strong",[v._v("25、Java提供了哪些IO方式?")])]),v._v(" "),_("p",[_("strong",[v._v("26、Cookie和Session的区别")])]),v._v(" "),_("p",[_("strong",[v._v("27、浏览器输入URL到页面展示中间发生了什么?")])]),v._v(" "),_("p",[_("strong",[v._v("28、说说线程的生命周期和状态?")])]),v._v(" "),_("p",[_("strong",[v._v("29、谈谈你对AOP的理解？")])]),v._v(" "),_("p",[_("strong",[v._v("30、进程间通信方式有哪些？")])]),v._v(" "),_("p",[_("strong",[v._v("31、数据库中MYISAM和InnoDB的区别")])]),v._v(" "),_("p",[_("strong",[v._v("32、数据库中char和varchar的区别")])]),v._v(" "),_("p",[_("strong",[v._v("33、MYSQL的事务的基本特性？")])]),v._v(" "),_("p",[_("strong",[v._v("34、Spring框架中用到的设计模式？")])]),v._v(" "),_("p",[_("strong",[v._v("35、Java的基本数据类型？")])]),v._v(" "),_("p",[_("strong",[v._v("36、谈谈Mysql的事务隔离级别？")])]),v._v(" "),_("p",[_("strong",[v._v("37、Spring IOC和DI的理解？")])]),v._v(" "),_("p",[_("strong",[v._v("38、Redis为什么这么快？")])]),v._v(" "),_("p",[_("strong",[v._v("39、说说线程的创建方式？")])]),v._v(" "),_("p",[_("strong",[v._v("40、SpringBoot的常用注解？")])]),v._v(" "),_("p",[_("strong",[v._v("41、try catch finally块 的使用？")])]),v._v(" "),_("p",[_("strong",[v._v("42、HashMap的底层实现？")])]),v._v(" "),_("p",[_("strong",[v._v("43、红黑树的特性和应用场景？")])]),v._v(" "),_("p",[_("strong",[v._v("44、HashMap为什么是线程不安全的，有什么解决办法？")])])])}),[],!1,null,null,null);_.default=r.exports}}]);