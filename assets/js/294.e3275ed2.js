(window.webpackJsonp=window.webpackJsonp||[]).push([[294],{752:function(v,_,t){"use strict";t.r(_);var n=t(1),s=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"jvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),_("p",[_("strong",[v._v("《深入理解")]),v._v("JVM**》"),_("strong",[v._v("周志明的，主要看")]),v._v("内存管理、垃圾回收、类加载机制、双亲委派机制**这几章即可")]),v._v(" "),_("p",[_("strong",[v._v("1、类加载机制：")])]),v._v(" "),_("p",[_("strong",[v._v("加载：")])]),v._v(" "),_("ul",[_("li",[v._v("通过一个类的全限定名来获取二进制字节流")]),v._v(" "),_("li",[v._v("这个字节流的静态存储结构转变成方法区的运行时数据结构")]),v._v(" "),_("li",[v._v("在内存中生成一个代表这个类的对象，作为方法区这个类的各种数据的访问入口")])]),v._v(" "),_("p",[_("strong",[v._v("验证：")])]),v._v(" "),_("ul",[_("li",[v._v("字节流是否符合class文件格式的规范")]),v._v(" "),_("li",[v._v("元数据验证")]),v._v(" "),_("li",[v._v("字节码验证：通过数据流和控制流的分析，确定语义是合法的")]),v._v(" "),_("li",[v._v("符号引用验证")])]),v._v(" "),_("p",[_("strong",[v._v("准备：")])]),v._v(" "),_("p",[v._v("初始值赋值")]),v._v(" "),_("p",[_("strong",[v._v("解析：")])]),v._v(" "),_("p",[v._v("类或接口的解析")]),v._v(" "),_("p",[v._v("字段解析")]),v._v(" "),_("p",[v._v("类方法解析：简单名称和描述符都和目标匹配的解析")]),v._v(" "),_("p",[v._v("接口方法解析")]),v._v(" "),_("p",[_("strong",[v._v("初始化：")])]),v._v(" "),_("p",[v._v("cinit")]),v._v(" "),_("p",[v._v("2、"),_("strong",[v._v("类加载器:双亲委派模型，四种加载器：启动类加载器，扩展类加载器，应用程序加载器，自定义类加载器")])]),v._v(" "),_("p",[_("strong",[v._v("3、 双亲委派机制讲解，为什么这样做？什么时候打破？")])]),v._v(" "),_("p",[v._v("双亲委派机制（Parent-Child Delegation）是Java安全模型中的一种权限控制机制，它允许代码根据代码签名的来源和代码运行的上下文，动态地确定代码对系统资源的访问权限。")]),v._v(" "),_("p",[v._v("在双亲委派机制中，每个类加载器都有一个父类加载器，当一个类加载器需要加载一个类时，它会先委托其父类加载器尝试加载该类，如果父类加载器无法加载该类，那么该类加载器自己才会尝试加载该类。这个过程会一直持续到最顶层的类加载器，通常是由Bootstrap ClassLoader加载Java核心类库。如果最终还是无法加载该类，则会抛出ClassNotFoundException异常。")]),v._v(" "),_("p",[v._v("这种双亲委派机制的优点是避免了重复加载类的问题，能够保证类的唯一性，并且能够防止恶意代码通过自定义类加载器篡改Java核心类库。同时，由于每个类加载器只加载自己的类和依赖的类，所以可以实现不同的类加载器加载不同版本的类，从而避免版本冲突问题。")]),v._v(" "),_("p",[v._v("但是，在某些情况下，需要打破双亲委派机制，例如在Web应用程序中，每个Web应用程序都有自己的类加载器，如果采用双亲委派机制，那么不同的Web应用程序可能会加载同一份类，从而造成冲突。在这种情况下，需要使用线程上下文类加载器（Thread Context ClassLoader）来打破双亲委派机制，让应用程序自己加载需要的类。另外，某些框架也需要打破双亲委派机制，例如OSGi框架。")]),v._v(" "),_("p",[v._v("总之，双亲委派机制是Java安全模型中的一种重要机制，它能够保证类的唯一性和版本的一致性，但在某些情况下需要打破该机制来满足特定的需求。")]),v._v(" "),_("p",[_("strong",[v._v("4、负载均衡策略")])]),v._v(" "),_("p",[v._v("负载均衡是分布式系统中常用的一种技术，它可以将请求平均分摊到多台服务器上，从而提高系统的性能和可靠性。不同的负载均衡策略适用于不同的场景和需求，下面是一些常见的负载均衡策略：")]),v._v(" "),_("ol",[_("li",[v._v("轮询策略（Round Robin）：轮询是一种简单的负载均衡算法，它将请求依次分配给不同的服务器。轮询策略可以确保每个服务器都能够接收到请求，但是当某个服务器的负载过高时，轮询算法无法进行动态调整。")]),v._v(" "),_("li",[v._v("最小连接数策略（Least Connections）：最小连接数策略会将请求分配给当前连接数最少的服务器。这种策略可以避免某些服务器因为连接数过高而出现性能问题，但是如果某些服务器的处理能力较弱，可能会导致负载不均衡。")]),v._v(" "),_("li",[v._v("IP 哈希策略（IP Hash）：IP 哈希策略会根据请求的源 IP 地址将请求分配给特定的服务器。这种策略可以确保同一客户端的请求都被分配到同一台服务器上，可以避免一些会话相关的问题。")]),v._v(" "),_("li",[v._v("加权轮询策略（Weighted Round Robin）：加权轮询策略会根据服务器的处理能力分配不同的权重，权重越高的服务器会接收到更多的请求。这种策略可以确保服务器的处理能力得到充分利用，但是需要对服务器的权重进行动态调整。")]),v._v(" "),_("li",[v._v("加权最小连接数策略（Weighted Least Connections）：加权最小连接数策略会根据服务器的处理能力和当前连接数，计算每个服务器的权重，然后将请求分配给权重最高的服务器。这种策略可以综合考虑服务器的处理能力和负载情况，但是计算权重的算法比较复杂。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);