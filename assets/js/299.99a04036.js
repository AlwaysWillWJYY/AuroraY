(window.webpackJsonp=window.webpackJsonp||[]).push([[299],{757:function(v,_,s){"use strict";s.r(_);var n=s(1),t=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"数据库-mysql45讲第30讲"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库-mysql45讲第30讲"}},[v._v("#")]),v._v(" 数据库(Mysql45讲第30讲)")]),v._v(" "),_("p",[_("strong",[v._v("Mysql事务、隔离级别、每个隔离级别的问题以及如何解决脏读、幻读问题？")])]),v._v(" "),_("p",[v._v("MySQL事务和隔离级别是保证数据一致性和并发性的重要机制。在MySQL中，有四个隔离级别，分别为读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。不同的隔离级别有不同的特点和问题，需要根据实际情况进行选择。")]),v._v(" "),_("p",[v._v("下面是每个隔离级别会出现的问题以及解决脏读、幻读等问题的方法：")]),v._v(" "),_("p",[v._v("​\t读未提交（Read Uncommitted） 该隔离级别允许一个事务读取另一个事务未提交的数据，因此可能出现脏读的问题。脏读是指一个事务读取到另一个事务尚未提交的数据，如果这个未提交的数据被回滚了，那么读取的数据就是错误的。")]),v._v(" "),_("p",[v._v("解决脏读的方法是使用锁机制，将读写操作限定在一个事务内，这样就可以保证读取到的数据都是已经提交的数据。")]),v._v(" "),_("p",[v._v("​\t读提交（Read Committed） 该隔离级别只允许一个事务读取另一个事务已经提交的数据，因此可以避免脏读的问题。但是，由于每次读取数据都要重新读取，因此可能出现幻读的问题。幻读是指在同一个事务中，前一次查询的结果和后一次查询的结果不一致。")]),v._v(" "),_("p",[v._v("解决幻读的方法是使用行级锁或快照读取。行级锁可以锁定某一行数据，保证在同一时间只有一个事务能够修改该行数据，从而避免了幻读的问题。快照读取是指在某一时间点读取数据的快照，而不是读取实时的数据，这样可以保证多次读取的结果一致。")]),v._v(" "),_("p",[v._v("​\t可重复读（Repeatable Read） 该隔离级别保证同一事务多次读取的数据一致，因此可以避免幻读的问题。但是，由于该隔离级别不会锁定读取的数据，因此可能出现非重复读的问题。非重复读是指在同一个事务中，前一次查询的结果和后一次查询的结果不一致。")]),v._v(" "),_("p",[v._v("解决非重复读的方法是使用行级锁或快照读取。")]),v._v(" "),_("p",[v._v("​\t 串行化（Serializable） 该隔离级别保证所有事务串行执行，因此可以避免所有的并发问题。但是，由于该隔离级别会锁定所有读写的数据，因此会对性能造成较大的影响。")]),v._v(" "),_("p",[v._v("总的来说，使用合适的隔离级别可以有效地避免脏读、幻读和非重复读等并发问题。")]),v._v(" "),_("p",[_("strong",[v._v("1、手撕SQL语句")])]),v._v(" "),_("div",{staticClass:"language-mysql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("# 有t表，有字段学生、科目、分数，要获取全部科目总分超过300分的同学及总分前3名\nSELECT 学生, SUM(分数) AS 总分\nFROM 表名\nGROUP BY 学生\nHAVING SUM(分数) > 300\nORDER BY 总分 DESC\nLIMIT 3\n\n\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br")])]),_("p",[_("strong",[v._v("2、数据库事务、隔离级别、Innodb和Myisam的区别")])]),v._v(" "),_("p",[v._v("读未提交，读已提交，可重复读，可串行化（分别解决了脏读，不可重复读，幻读的问题）")]),v._v(" "),_("p",[_("strong",[v._v("3、锁机制（悲观锁、乐观锁、行锁表锁、独占锁共享锁等等）")])]),v._v(" "),_("p",[v._v("全局锁，表锁，行锁")]),v._v(" "),_("p",[v._v("怎么减少行锁对性能的影响：控制并发度减少死锁检测的时间.")]),v._v(" "),_("p",[v._v("MySQL中的锁机制包括表锁和行锁，它们在不同的场景下使用。以下是它们的应用场景：")]),v._v(" "),_("ol",[_("li",[v._v("表锁：适用于对大量数据进行批量处理的情况，例如ALTER TABLE、OPTIMIZE TABLE、REPAIR TABLE等操作。表锁是对整张表进行加锁，其他的事务要么等待锁的释放，要么被阻塞，直到表锁被释放。在使用表锁时需要注意的是，由于表锁的粒度比较大，容易导致锁冲突，影响并发性能。")]),v._v(" "),_("li",[v._v("行锁：适用于对少量数据进行操作的情况，例如UPDATE、DELETE、SELECT FOR UPDATE等操作。行锁只会对需要操作的行进行加锁，不会对其他行产生阻塞。这样能够提高并发性能，减少锁冲突的可能。需要注意的是，行锁对查询性能的影响比较大，因为需要对每一行都进行加锁和解锁操作，如果处理的数据量比较大，会导致锁的粒度过细，从而降低并发性能。")])]),v._v(" "),_("p",[v._v("总的来说，表锁适用于对大量数据进行批量处理的情况，而行锁适用于对少量数据进行操作的情况。在实际使用时，应根据业务场景和数据量大小选择适当的锁机制，以保证数据的一致性和并发性能。")]),v._v(" "),_("p",[_("strong",[v._v("4、MVCC、NK-Lock")])]),v._v(" "),_("p",[v._v("MVCC加rowxid和undolog、next-key lock锁")]),v._v(" "),_("p",[_("strong",[v._v("5、索引的数据结构（B+树）、索引优缺点")])]),v._v(" "),_("p",[v._v("索引占用空间，不用全表扫描，查询速度加快.")]),v._v(" "),_("p",[_("strong",[v._v("6、最左前缀原则、索引优化")])]),v._v(" "),_("p",[v._v("联合索引，索引下推减少回表次数,前缀索引")]),v._v(" "),_("p",[_("strong",[v._v("7、聚簇索引、覆盖索引")])]),v._v(" "),_("p",[v._v("要查询的结果在叶子结点，要查询的结果列在索引字段就已经满足了。")]),v._v(" "),_("p",[v._v("普通索引和唯一索引的区别？一般建立普通索引，主要比对更新操作，change buuffer原理，优化读，redo log优化写")]),v._v(" "),_("p",[_("strong",[v._v("8、数据库三大范式")])]),v._v(" "),_("p",[_("strong",[v._v("9、主从复制、主从一致、分库分表等等问题")])]),v._v(" "),_("p",[v._v("主备延迟的来源：\n1.主库DML语句并发大,从库qps高\n2.从库服务器配置差或者一台服务器上几台从库(资源竞争激烈,特别是io)\n3.主库和从库的参数配置不一样\n4.大事务(DDL,我觉得DDL也相当于一个大事务)\n5.从库上在进行备份操作\n6.表上无主键的情况(主库利用索引更改数据,备库回放只能用全表扫描,这种情况可以调整slave_rows_search_algorithms参数适当优化下)\n7.设置的是延迟备库\n8.备库空间不足的情况下")]),v._v(" "),_("p",[_("strong",[v._v("首先，有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。")]),v._v(" "),_("strong",[v._v("第二种常见的可能了，即备库的压力大")]),v._v(" ，第三是"),_("strong",[v._v("大事务")])]),v._v(" "),_("p",[_("strong",[v._v("备库的并行复制能力")]),v._v(" ：多线程模型加waitset判断事务操作的数据行是否是在同一个set里（可靠性和可用性，主备数据不一致可靠性差）")]),v._v(" "),_("p",[_("strong",[v._v("10、加锁规则:nk,间隙锁，行锁转换等等.")])]),v._v(" "),_("p",[_("strong",[v._v("11、介绍一下倒排索引")])]),v._v(" "),_("p",[v._v("倒排索引（Inverted Index）是一种常用的文本索引方法，它可以快速地将文本数据中的单词（或者其他的词汇单位）映射到包含这些单词的文档中。")]),v._v(" "),_("p",[v._v("倒排索引的基本思想是将文档中的每个单词都作为关键词进行索引。具体地，对于文档集合中的每一篇文档，倒排索引会记录下该文档包含哪些单词，以及这些单词分别在文档中出现了哪些位置。这样，当用户查询某个单词时，系统可以快速地找到包含该单词的文档，从而实现文本检索。")]),v._v(" "),_("p",[v._v("倒排索引的优点在于，它可以快速地进行文本检索，特别是在大规模文本数据集合中。同时，由于倒排索引中存储的是单词和文档之间的映射关系，因此它也可以被用来进行文本分析，例如计算单词在文档集合中的出现频率、词频统计等。")])])}),[],!1,null,null,null);_.default=t.exports}}]);